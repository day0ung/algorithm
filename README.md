# alotorithm

<sub> Beakjoon_Hub를 사용하기위해 새로운 repo를 생성하고 그곳에서 작업하다가    
git -mirror로 이곳 repository와 병합하려했는데, 재배치 하면서 기존에 했던 코드들이 삭제되었다. 슬프지만, Greedy부터 다시 시작</sub>

####  [그리디 알고리즘](#-greedy)
#### [다이나믹 프로그래밍 알고리즘](#-dynamic-programming)



### 📌 Greedy 
Greedy 알고리즘은 최적해를 구하는 데 사용되는 알고리즘 중 하나로, 각 단계에서 지금 당장 가장 좋아보이는 선택을 하는 방식으로 문제를 해결한다.  
각 단계에서 지금 선택한 것이 지역적으로는 가장 최선의 선택일 수 있지만, 이 선택들을 계속 수집하여 최종적인 해답을 만들었을 때 전역적으로도 최적의 해를 구할 수 있다. 
 
**Greedy 알고리즘의 특징**
* 탐욕적 선택 속성(Greedy-choice property): 각 단계에서 가장 좋아보이는 선택을 합니다. 이 선택이 최적이라면, 전체 문제에 대한 최적해에 포함된다.
* 최적 부분 구조(Optimal substructure): 각 단계의 선택은 다음 단계의 선택에 영향을 주지 않으며, 각 단계에서의 선택들을 모아 전체적인 최적해를 구할 수 있다.

**Greedy 알고리즘의 대표적인 문제**
* 거스름돈 문제: 가장 적은 수의 동전으로 거스름돈을 주는 방법을 찾는 문제
* 탐욕적 스케줄링: 가장 빨리 끝나는 작업을 우선으로 처리하는 작업 스케줄링 문제
* 최소 신장 트리: 가중치가 있는 그래프에서 모든 정점을 포함하면서 간선의 가중치 합이 최소인 트리를 구하는 문제 등

### 📌 Dynamic Programming
Dynamic Programming(동적계획법)이란, 큰 문제를 작은문제로 나누어 푸는 문제를 일컫는 말이다.  
주어진 문제를 더 작은 하위 문제들로 나누고, 각 하위 문제들의 결과를 저장하며 점진적으로 문제를 해결해 나갑니다. 작은 하위 문제들의 결과를 저장하기 위해 메모이제이션(Memoization) 기법을 사용한다.  

다이나믹 프로그래밍은 중복되는 하위 문제들이 존재하고, 각 하위 문제의 해결 결과가 동일한 경우에 효과적이다. 이전에 계산한 값을 저장해두고 필요할 때 재사용함으로써 중복 계산을 피하고 실행 속도를 향상시킬 수 있다.

다이나믹 프로그래밍은 일반적으로 다음과 같은 단계로 진행된다:
1. 문제를 작은 하위 문제들로 분할합니다.
2. 하위 문제들을 재귀적으로 해결하면서 중간 결과를 저장합니다.
3. 작은 하위 문제들의 결과를 이용하여 큰 문제의 해결 결과를 도출합니다.

**Dynamic Programming의 특징**  
* 작은 문제들이 반복된다. 
* 같은 문제는 구할 때 마다 정답이 같다 

**Dynamic Programming의 대표적 문제**  
* 최적화 문제나 조합 문제 등
* 피보나치 수열, 배낭 문제, 최장 공통 부분 수열(LCS) 등

> **Memoization?**  
메모이제이션은 앞서 말했듯 동적프로그래밍에서는 작은 문제들이 반복되고 이 작은 문제들의 결과값이 항상 같습니다. 때문에 이점을 이용하여 한번 계산한 작은 문제를 저장해놓고 다시 사용을 한다. 이것을 Memoization이라고 한다.
피보나치를 예로, 피보나치는 1,1,2,3,5,8 ...의 수을 이루게 된다. 즉, '다음수열= 이전 수열 + 두단계 전 수열의 합' 이라는 점화식을 갖는 순열이다.  
*재귀 함수*로 풀게되면 이보다도 훨씬 간단하게 풀 수 있지만 n이 증가함에 따라 호출되는 함수의 수가 기하급수 적으로 증가하기 때문에 일정 수 이상의 순열을 구하기가 어렵다.  
> 또한 이렇게 fibonacci를 재귀함수로 풀게될 경우, 위의 그림처럼 했던 작업을 또 하게 됩니다. 이럴 때 위에서 살펴본 동적계획법의 조건두가지를 상기해보면 이를 동적계획법을 이용해 풀 수 있다는 사실을 알 수 있다.